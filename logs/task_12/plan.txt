================================================================================
INITIAL PLAN
================================================================================
Created: 2025-12-09 19:34:48

Steps:
  1. Search internal wiki or company documentation for an explicit company-defined meaning of "busiest employee" and any standard metric, formula, report, or guideline used to measure how busy an employee is (for example, utilization, workload, total hours, number of projects).
     Approach: Use a wiki or documentation search function (for example, search_wiki_fuzzy) to perform a FUZZY and SEMANTIC / LOGICAL search for terms and their possible abbreviations or variants, including but not limited to "busiest employee", "employee workload", "utilization", "capacity planning", "workload metric", and "Vienna office workload". Account for typos, partial matches, and alternate wording (for example, "busy", "overloaded", "most utilized"). If multiple documents are found, prioritize any that explicitly define how "busiest" is measured at company level. Extract whether there is a clear definition, the description text, the metric type (for example, "total logged hours", "utilization percentage", "sum of time_slice"), and any defined time window (for example, last 30 days).
     Expected Output: {"type":"object","properties":{"definition_found":{"type":"boolean"},"definition_text":{"type":["string","null"]},"metric_type":{"type":["string","null"]},"lookback_period_days":{"type":["integer","null"]},"metric_defined":{"type":"boolean"}},"required":["definition_found","metric_defined"]}
  2. Search for any existing technical implementation (reports, dashboards, SQL views, API endpoints, or automated jobs) that already calculate employee workload or busyness, especially by location such as Vienna, to reuse instead of implementing logic from scratch.
     Approach: Perform a FUZZY and SEMANTIC / LOGICAL search across internal technical documentation, system catalogs, and wiki pages for terms like "workload report", "employee utilization dashboard", "time tracking summary", "capacity report", "Vienna workload", and similar. Account for typos, partial names, and abbreviations. Include fuzzy matching and partial string search across object names, descriptions, and identifiers. If found, list all relevant implementations with their names, locations (for example, BI tool, internal web application, SQL view), input parameters, and whether they support filtering by location. If nothing relevant or only unrelated items are found, mark implementation_found as false.
     Expected Output: {"type":"object","properties":{"implementation_found":{"type":"boolean"},"implementations":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"type":{"type":"string"},"supports_location_filter":{"type":"boolean"}},"required":["name","type","supports_location_filter"]}}},"required":["implementation_found","implementations"]}
  3. Determine which data sources will be used to assess how busy employees in Vienna are and check that the current user (Giorgia Ricci, Finance and Administration, HQ – Italy) has permission to read the necessary non-sensitive data.
     Approach: Based on the results of steps 1 and 2, decide whether to use an existing implementation (for example, a workload report) or to directly query core SQL tables such as employee, team_member, and time_entry. Ensure that only allowed, non-sensitive fields are planned for use: from employee, use id, name, email, location, and department but explicitly avoid salary and notes; from time_entry, use employee_id, project_id, customer_id, entry_date, hours, status; from team_member, use project_id, employee_id, role, and time_slice. Then call a who_am_i() or equivalent identity function to confirm the current user identity and roles, and check against company policies that a Finance and Administration user can read these non-sensitive fields for analysis purposes. Do not proceed to computation if policy denies access.
     Expected Output: {"type":"object","properties":{"can_proceed":{"type":"boolean"},"reason_if_denied":{"type":["string","null"]},"data_sources":{"type":"array","items":{"type":"string"}}},"required":["can_proceed","data_sources"]}
  4. Query core tables to build workload or busyness metrics for all employees located in Vienna, according to the company definition from step 1 or, if none exists, using total logged work hours as the proxy metric.
     Approach: Using SQL, first select all employees whose location corresponds to Vienna by filtering employee.location with an exact match on 'Vienna' where possible and, if needed, FUZZY and SEMANTIC / LOGICAL matching against the location table to handle possible variants or typos (for example, 'Wien', 'Vienna Office – Austria'). Use only non-sensitive columns (id, name, email, location, department). For these Vienna employees, compute workload metrics depending on the metric_type and lookback_period_days from step 1: for example, if the metric is total logged hours in a given period, join time_entry on employee_id and sum hours grouped by employee within the defined time window; if the metric involves utilization or time_slice, join team_member and aggregate time_slice across active projects. If no explicit metric is defined in step 1, compute at least: (a) total logged hours per employee over a reasonable standard period such as the last 30 days, and (b) number of distinct projects from time_entry or team_member, documenting that these are used as a proxy for busyness. Ensure searches for employee ids and project ids account for potential typos or inconsistent naming via fuzzy matching only when exact joins fail. Produce a per-employee record containing identifiers and computed metrics, and a derived busyness_score (for example, equal to total_hours if no more complex formula is defined).
     Expected Output: {"type":"object","properties":{"location_filtered":{"type":"string"},"metric_used":{"type":"string"},"employees":{"type":"array","items":{"type":"object","properties":{"employee_id":{"type":"string"},"employee_name":{"type":"string"},"total_hours":{"type":"number"},"num_projects":{"type":"integer"},"busyness_score":{"type":"number"}},"required":["employee_id","employee_name","busyness_score"]}}},"required":["location_filtered","metric_used","employees"]}
  5. Identify which employee or employees in Vienna is the busiest based on the computed busyness_score and prepare the final, unambiguous result.
     Approach: From the per-employee metrics produced in step 4, determine the maximum busyness_score value. Select all Vienna employees whose busyness_score equals this maximum, thereby handling any ties explicitly. If the employees array is empty or all scores are missing, report that no busiest employee can be determined. Otherwise, output the busiest employee or list of employees (in case of a tie), including their ids, names, busyness_score, and a clear description of the metric and time window used. No additional data (such as salary or HR notes) should be included. This step involves only in-memory comparison and simple aggregation; no new logging or data persistence is performed.
     Expected Output: {"type":"object","properties":{"location":{"type":"string"},"metric_description":{"type":"string"},"busiest_employees":{"type":"array","items":{"type":"object","properties":{"employee_id":{"type":"string"},"employee_name":{"type":"string"},"busyness_score":{"type":"number"},"is_tie":{"type":"boolean"}},"required":["employee_id","employee_name","busyness_score","is_tie"]}}},"required":["location","metric_description","busiest_employees"]}
