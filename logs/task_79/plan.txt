================================================================================
INITIAL PLAN
================================================================================
Created: 2025-12-09 23:17:58

Steps:
  1. Search internal wiki and documentation for the company-specific definitions of the terms "workload" and "current projects" as they relate to employees and projects, to understand exactly what should be calculated for the workload of an employee across projects.
     Approach: Use a FUZZY and SEMANTIC / LOGICAL search over wiki_file records and any available internal documentation search tools with queries such as "workload definition", "employee workload", "current projects", "project workload". Account for typos, pluralization, and variations (for example, "work load", "current proj."). Prefer exact matches in titles and headings first, then contents. If multiple relevant definitions are found, select the one most specifically related to employee allocation across projects. If no explicit definition is found, note that and default later to using the most logical technical representation of workload (for example, team_member.time_slice) while clearly documenting this assumption.
     Expected Output: {"type":"object","properties":{"definition_found":{"type":"boolean"},"workload_definition_text":{"type":["string","null"]},"current_projects_definition_text":{"type":["string","null"]}},"required":["definition_found","workload_definition_text","current_projects_definition_text"]}
  2. Identify which technical data structures or services in the available systems represent an employee's workload and project participation, to know exactly where and how to retrieve workload data.
     Approach: Inspect the known SQL schema and, if available, any service or API catalog using a FUZZY and SEMANTIC / LOGICAL search for relevant entities and fields such as "team_member", "time_slice", "workload", "capacity", "allocation". Pay particular attention to the team_member table (project_id, employee_id, role, time_slice) and the time_entry table to see which is used by internal guidelines (from Step 1) for workload reporting. Confirm whether workload across current projects should be derived from team_member.time_slice (fraction of full-time per project) and whether any additional constraints (such as project status) are part of the technical definition. If no appropriate field or service is found that can express workload, record that the required functionality is not implemented.
     Expected Output: {"type":"object","properties":{"workload_source_type":{"type":"string","enum":["team_member_time_slice","time_entry_hours","unknown"]},"primary_tables":{"type":"array","items":{"type":"string"}},"workload_fields":{"type":"array","items":{"type":"string"}},"supports_project_status_filtering":{"type":"boolean"}},"required":["workload_source_type","primary_tables","workload_fields","supports_project_status_filtering"]}
  3. Locate the exact employee record corresponding to "Marchetti Camilla" in the employee table to obtain a stable employee_id for subsequent queries.
     Approach: Query the employee table using a combination of exact and FUZZY and SEMANTIC / LOGICAL matching on the name field, and if needed on id and email fields. First try exact match on name = 'Marchetti Camilla'. If no record is found, relax the search by lowercasing and trimming whitespace and checking whether 'marchetti' and 'camilla' are contained in the name, then use fuzzy string comparison (for example, Levenshtein distance) to handle typos or different order (such as 'Camilla Marchetti'). If multiple candidates are returned, rank them by fuzzy similarity score and select the top candidate only if its similarity score is clearly higher than others (for example, by a defined margin); otherwise, mark the result as ambiguous and require clarification. Capture whether a unique employee was found and, if so, the corresponding employee_id and canonical name.
     Expected Output: {"type":"object","properties":{"found":{"type":"boolean"},"ambiguous":{"type":"boolean"},"candidate_count":{"type":"integer"},"employee_id":{"type":["string","null"]},"employee_name":{"type":["string","null"]}},"required":["found","ambiguous","candidate_count","employee_id","employee_name"]}
  4. Check whether the current user (Nino Valente, id FphR_001) has sufficient permissions and role to view the workload of the identified employee across projects.
     Approach: Call a who_am_i() or equivalent identity and authorization lookup to confirm the current user's employee_id, department, and roles (for example, 'Executive Leadership', 'DepartmentLeader'). Using FUZZY and SEMANTIC / LOGICAL matching if role naming is not standardized, verify that the user belongs to an executive or otherwise authorized group that is allowed to see cross-project workload for other employees (for example, executives or direct managers). Evaluate access based on the company rules that executives and corporate leadership can access any project and client information. If the user does not have appropriate roles or if the policy lookup fails, set the outcome as denied_security and do not proceed to read detailed workload data.
     Expected Output: {"type":"object","properties":{"current_user_id":{"type":"string"},"current_user_roles":{"type":"array","items":{"type":"string"}},"permission_to_view_workload":{"type":"boolean"},"denial_reason":{"type":["string","null"]}},"required":["current_user_id","current_user_roles","permission_to_view_workload","denial_reason"]}
  5. Retrieve and aggregate the workload of the identified employee (Marchetti Camilla) across all current projects, using the technical workload representation discovered earlier and any definition of "current projects" from documentation.
     Approach: Assuming permission is granted and a unique employee_id was found, query the primary workload source determined in Step 2. If workload_source_type is 'team_member_time_slice', perform a JOIN between team_member and project on project_id, filtered by team_member.employee_id equal to the identified employee_id. If the documentation from Step 1 defines "current projects" in terms of project.status (for example, excluding 'archived'), apply that filter; otherwise, include all projects where the employee is a team member, without introducing additional status checks. For each matching project, retrieve project.id, project.name, project.customer_id, team_member.role, and team_member.time_slice. Compute the total allocated time_slice across all these projects (sum of time_slice) and prepare a per-project list showing each project's allocation. If workload_source_type is 'time_entry_hours', instead aggregate hours from time_entry grouped by project_id over the relevant recent period defined in the documentation (using FUZZY and SEMANTIC / LOGICAL interpretation if the period is described in words, such as "current month"). If workload_source_type is 'unknown', do not attempt to fabricate results and mark that workload cannot be computed due to missing implementation.
     Expected Output: {"type":"object","properties":{"employee_id":{"type":"string"},"projects":{"type":"array","items":{"type":"object","properties":{"project_id":{"type":"string"},"project_name":{"type":"string"},"customer_id":{"type":["string","null"]},"role":{"type":["string","null"]},"time_slice":{"type":["number","null"]},"total_hours":{"type":["number","null"]}},"required":["project_id","project_name"]}},"total_allocated_time_slice":{"type":["number","null"]},"workload_computable":{"type":"boolean"}},"required":["employee_id","projects","total_allocated_time_slice","workload_computable"]}
  6. If at any earlier step the necessary technical implementation for workload is missing, the employee cannot be uniquely identified, or permissions are denied, abort the task explicitly with a clear reason indicating that the workload cannot be provided.
     Approach: Review the outputs from Steps 2, 3, 4, and 5. If workload_source_type is 'unknown', or Step 3 indicates that the employee was not found or is ambiguous, or Step 4 indicates permission_to_view_workload is false, construct an abort outcome that clearly specifies whether the cause is missing implementation, missing or ambiguous employee, or denied_security. Do not attempt to infer or estimate workload without proper data. This step should not perform any new data queries; it only interprets prior results and decides whether to present the computed workload or return an appropriate abort message.
     Expected Output: {"type":"object","properties":{"should_abort":{"type":"boolean"},"abort_reason":{"type":["string","null"]}},"required":["should_abort","abort_reason"]}
