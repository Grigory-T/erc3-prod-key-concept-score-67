================================================================================
INITIAL PLAN
================================================================================
Created: 2025-12-10 00:12:58

Steps:
  1. Resolve the current authenticated user 'SrwB_017' to an employee record in the employee table in order to know which skills belong to this user.
     Approach: Use the bound user context (id 'SrwB_017', name 'Mia Hoffmann', department 'Sales & Customer Success', location 'Munich Office – Germany') to search the employee table. First attempt an exact match on employee.id = 'SrwB_017'. If no exact match is found, perform a **FUZZY** and **SEMANTIC / LOGICAL** search using variations of the user identifier, full name, and email (if available): normalize strings to lowercase, trim whitespace, check substring containment (using logic similar to Python 'in' operator), then use fuzzy matching (e.g., fuzzy_compare, fuzzy_find_in_text) on employee.name and employee.email and, as a last resort, list all employees and try to identify the best candidate by similarity. Account for possible typos, misspellings, or formatting differences in the employee identifier or name.
     Expected Output: {"type":"object","properties":{"employee_id":{"type":"string"},"employee_found":{"type":"boolean"},"matching_strategy":{"type":"string"},"candidate_employee_ids":{"type":"array","items":{"type":"string"}}},"required":["employee_found","candidate_employee_ids"]}
  2. Check permissions and access restrictions for the resolved employee to ensure that the current user is allowed to read her own skills and the global skill names needed to compute skills she does not have.
     Approach: Call a who_am_i() or equivalent identity/authorization check using the resolved employee_id from Step 1 and the bound context (user.id = 'SrwB_017', department 'Sales & Customer Success', location 'Munich Office – Germany'). Verify that the user is an internal, authenticated employee (is_public = False). Confirm that reading from the employee_skill table (fields: employee_id, skill_name, level, skill_type) does not violate any salary or HR notes restrictions and is permitted for this user. Do not attempt to access any salary or hr_notes fields. The outcome should explicitly state whether the user is allowed to proceed with reading her own skills and aggregating distinct skill_name values from all employees.
     Expected Output: {"type":"object","properties":{"allowed":{"type":"boolean"},"reason":{"type":"string"}},"required":["allowed","reason"]}
  3. Retrieve the complete set of distinct skill names defined in the system so we can later determine which of these the current user does not have.
     Approach: Query the employee_skill table to obtain all distinct skill_name values that are of type 'skill' (skill_type = 'skill'). Use a SELECT DISTINCT skill_name FROM employee_skill WHERE skill_type = 'skill' style query. If there is a need to filter out clearly invalid or duplicate-looking names (for example, capitalization differences or leading/trailing whitespace), normalize skill_name values by trimming whitespace and converting to a consistent case for comparison while preserving the original text for display. Because skill names may include typos or minor variations, keep all distinct normalized values, but if desired, you may group obviously identical names using **FUZZY** and **SEMANTIC / LOGICAL** comparison (e.g., fuzzy_compare on normalized strings) to reduce accidental duplicates while not removing genuinely different skills.
     Expected Output: {"type":"object","properties":{"all_skills":{"type":"array","items":{"type":"string"}}},"required":["all_skills"]}
  4. Retrieve the list of skill names that the current user already has, in order to later compute which skills she does not have.
     Approach: Using the resolved employee_id from Step 1 (for example 'SrwB_017' or whatever exact id was found), query the employee_skill table for that employee with skill_type = 'skill'. Use a query such as: SELECT skill_name FROM employee_skill WHERE employee_id = <resolved_employee_id> AND skill_type = 'skill'. Normalize skill_name values similarly to Step 3 (trim whitespace, standardize case for comparison) while preserving original text for display. If the employee has no skill records, return an empty list. If there are potential duplicates or minor spelling variations for the same underlying skill for this user, you may optionally deduplicate them using **FUZZY** and **SEMANTIC / LOGICAL** matching on the normalized names.
     Expected Output: {"type":"object","properties":{"employee_id":{"type":"string"},"user_skills":{"type":"array","items":{"type":"string"}}},"required":["employee_id","user_skills"]}
  5. Compute the set of skills that the current user does not have and format them as a table of skills and their names.
     Approach: Using the all_skills list from Step 3 and the user_skills list from Step 4, normalize both lists in the same way (e.g., lowercase, trimmed) for comparison. Compute the set difference: skills_not_owned = {s in all_skills | normalized(s) not in {normalized(us) for us in user_skills}}. Because the task requests a table of skills and their names, construct a tabular structure (for example, an array of objects) where each row represents one missing skill with at least a 'skill_name' field containing the display name of the skill. If you choose to include both an internal key and a display name, ensure that any such key is derived deterministically from the actual skill_name (for example, a slug), not from invented data. The final output should strictly list only those skills present in the system that the user does not currently have.
     Expected Output: {"type":"object","properties":{"skills_not_owned":{"type":"array","items":{"type":"object","properties":{"skill_name":{"type":"string"}},"required":["skill_name"]}}},"required":["skills_not_owned"]}
