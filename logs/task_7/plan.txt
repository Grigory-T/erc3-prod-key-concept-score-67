================================================================================
INITIAL PLAN
================================================================================
Created: 2025-12-09 19:16:09

Steps:
  1. Identify the current authenticated user in the employee registry and retrieve their internal employee identifier and roles to know whose projects are referred to as 'my projects' (this is Irene Venturi).
     Approach: Call the identity/EmployeeRegistry service (who_am_i) to get the bound employee record for the current session (user id 'FphR_006'). If there is any mismatch between the session identity and the employee table (for example, difference between account id, email, and full name), resolve it by searching the employee table using a **fuzzy** and **semantic / logical** search on name and email (handle possible misspellings, extra spaces, different ordering of first and last name). Prefer exact matches on technical identifiers if available, and only fall back to fuzzy matching if needed.
     Expected Output: {"type":"object","properties":{"user_id":{"type":"string"},"employee_id":{"type":"string"},"name":{"type":"string"},"department":{"type":"string"},"location":{"type":"string"},"system_roles":{"type":"array","items":{"type":"string"}}},"required":["user_id","employee_id","name"]}
  2. Resolve the person 'Coppola Noemi' to an internal employee record in the employee table.
     Approach: Query the employee table for candidates whose name matches 'Coppola Noemi'. First try an exact match on the full name (case-insensitive, trimmed). If that fails or returns multiple entries, apply **fuzzy** and **semantic / logical** matching: split into first name and last name, search for rows where both tokens appear in any order in the name field, allow for partial matches and typical misspellings, and consider alternative spacing or accents. If still ambiguous, compute a fuzzy similarity score (e.g. using fuzzy_compare) and return the top N candidates with their confidence scores, without auto-selecting when multiple candidates have similar scores.
     Expected Output: {"type":"object","properties":{"target_name":{"type":"string"},"matches":{"type":"array","items":{"type":"object","properties":{"employee_id":{"type":"string"},"name":{"type":"string"},"email":{"type":"string"},"confidence":{"type":"number"}},"required":["employee_id","name","confidence"]}}},"required":["target_name","matches"]}
  3. Retrieve the list of all projects in which the current user (identified in step 1) is a team member; this defines 'my projects'.
     Approach: Using the employee_id from step 1, query the team_member table with an exact match on employee_id. Collect all related project_id values. Then query the project table by these project_id values (using an exact match on the identifiers) to obtain project details (name, status, customer_id, description). Do not filter by project status (include idea, exploring, active, paused, archived). No fuzzy logic is needed on project_id, but if any join by name is required later, use **fuzzy**, partial, and **semantic / logical** matching as per the general search strategy.
     Expected Output: {"type":"object","properties":{"employee_id":{"type":"string"},"projects":{"type":"array","items":{"type":"object","properties":{"project_id":{"type":"string"},"name":{"type":"string"},"customer_id":{"type":["string","null"]},"status":{"type":"string"}},"required":["project_id","name","status"]}}},"required":["employee_id","projects"]}
  4. Retrieve the list of all projects in which the resolved employee 'Coppola Noemi' is a team member.
     Approach: Take the chosen employee_id for 'Coppola Noemi' from step 2. Query the team_member table for rows with an exact match on this employee_id and collect all project_id values. Then query the project table for these project_id values to get project details (name, status, customer_id, description). Use exact matches on identifiers; if any discrepancy appears (for example, due to inconsistent identifiers), resolve it via **fuzzy** and **semantic / logical** matching between team_member.project_id and project.id, while preferring exact matches whenever possible.
     Expected Output: {"type":"object","properties":{"employee_id":{"type":"string"},"projects":{"type":"array","items":{"type":"object","properties":{"project_id":{"type":"string"},"name":{"type":"string"},"customer_id":{"type":["string","null"]},"status":{"type":"string"}},"required":["project_id","name","status"]}}},"required":["employee_id","projects"]}
  5. Check permissions and access restrictions to confirm that the current user is allowed to view which of their own projects involve another employee and to access project membership information.
     Approach: Using the current user's identity and roles from step 1 (system_roles, department, location) and the company rules, evaluate whether reading project and team_member data for projects that the user is part of is permitted. Since the documented restrictions apply mainly to writing or mutating data (creating or updating customers, projects, time entries, skills, and accessing salary), verify that this read-only query about project participation does not violate any listed restrictions. Explicitly confirm that no salary, human resources notes, or other restricted fields are accessed. If any rule is found that would forbid this read access (for example, if a stricter internal policy exists), mark access as denied; otherwise, mark it as allowed.
     Expected Output: {"type":"object","properties":{"can_view":{"type":"boolean"},"reason":{"type":"string"}},"required":["can_view","reason"]}
  6. Determine in which of the current user's projects the employee 'Coppola Noemi' is involved, and prepare the final list of shared projects.
     Approach: Provided that step 5 confirms access is allowed, compute the intersection between the project lists from step 3 (current user's projects) and step 4 ('Coppola Noemi' projects) using exact equality on project_id. For each project_id that appears in both lists, construct a result entry including project_id, project name, status, and customer_id (if available). If 'Coppola Noemi' could not be uniquely identified in step 2, or if there are no common projects, handle this gracefully by returning an empty list of shared projects while still providing the current user's and the colleague's identifiers. If access was denied in step 5, do not include project details and instead reflect that in the output according to the permission status.
     Expected Output: {"type":"object","properties":{"current_user_employee_id":{"type":"string"},"colleague_employee_id":{"type":["string","null"]},"shared_projects":{"type":"array","items":{"type":"object","properties":{"project_id":{"type":"string"},"name":{"type":"string"},"customer_id":{"type":["string","null"]},"status":{"type":"string"}},"required":["project_id","name","status"]}}},"required":["current_user_employee_id","colleague_employee_id","shared_projects"]}
